/*
Problem 1: Fizz Buzz

Challenge Description:

Players generally sit in a circle. The player designated to go first says the number "1", and each
player thenceforth counts one number in turn. However, any number divisible by 'A' e.g. three is
replaced by the word fizz and any divisible by 'B' e.g. five by the word buzz. Numbers divisible by
both become fizz buzz. A player who hesitates or makes a mistake is either eliminated.

Write a program that prints out the the pattern generated by such a scenario given the values of
'A'/'B' and 'N' which are read from an input text file. The input text file contains three space
delimited numbers i.e. A, B, N. The program should then print out the final series of numbers using
'F' for fizz, 'B' for 'buzz' and 'FB' for fizz buzz.

Input sample:

Your program should read an input file (provided on the command line) which contains multiple
newline separated lines. Each line will contain 3 numbers which are space delimited. The first
number is first number to divide by ('A' in this example), the second number is the second number to
divide by ('B' in this example) and the third number is where you should count till ('N' in this
example). You may assume that the input file is formatted correctly and is the numbers are valid
positive integers. E.g.
    3 5 10
    2 7 15
Output sample:

Print out the series 1 through N replacing numbers divisible by 'A' by F, numbers divisible by 'B'
by B and numbers divisible by both as 'FB'. Since the input file contains multiple sets of values,
your output will print out one line per set. Ensure that there are no trailing empty spaces on each
line you print. E.g.
    1 2 F 4 B F 7 8 F B
    1 F 3 F 5 F B F 9 F 11 F 13 FB 15
*/
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

var line string

// check(err) eliminates some boilerplate
func check(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Usage: ./problem1 <file>")
		os.Exit(1)
	}
	lines := readLines()
	for _, line := range lines {
		text := strings.Split(line, " ")
		a, err := strconv.Atoi(text[0])
		check(err)
		b, err := strconv.Atoi(text[1])
		check(err)
		n, err := strconv.Atoi(text[2])
		check(err)
		line = ""
		for i := 1; i <= n; i++ {
			switch {
			case i%a == 0 && i%b == 0:
				line += "FB "
			case i%a == 0:
				line += "F "
			case i%b == 0:
				line += "B "
			default:
				line += fmt.Sprintf("%d ", i)
			}
		}
		fmt.Println(line[:len(line)-1])
	}
}

// readLines does the work bufio's scanner API would do, but CodeEval doesn't have Go 1.1 yet.
func readLines() (lines []string) {
	// Avoid a panic accessing os.Args[1]
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Usage: ./XXX <file>") // XXX
		os.Exit(1)
	}

	// Read data from a file given as a command line argument
	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	// Parse the lines of the file from data
	lines = strings.Split(string(data), "\n")

	// Remove the empty string after the final \n
	lines = lines[:len(lines)-1]

	return
}
